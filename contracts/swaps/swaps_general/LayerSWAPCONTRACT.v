(* WARNING: This file is generated by Edsger, the DeepSEA compiler.
            All modification will be lost when regenerating. *)
(* Module swaps_general.LayerSWAPCONTRACT for swaps_general.ds *)
Require Import BinPos.
Require Import DeepSpec.Runtime.
Require Import swaps_general.EdsgerIdents.
Require Import swaps_general.DataTypes.
Require Import swaps_general.DataTypeOps.
Require Import swaps_general.DataTypeProofs.
(*Require Import liblayers.compcertx.MakeProgram.
Require Import liblayers.compcertx.MemWithData.*)
Require Import DeepSpec.lib.Monad.Monad.
Require Import DeepSpec.lib.Monad.MonadState.
Require Import DeepSpec.lib.Monad.StateMonad.
Require Import DeepSpec.lib.Monad.OptionMonad.
Require Import DeepSpec.lib.Monad.MonadZero.
Require Import DeepSpec.core.SynthesisStmt.
Require Import backend.MachineModel.
Existing Instance MonadState_DS.
Existing Instance MonadZero_DS.
Require Export swaps_general.LayerEVMOPCODE.

Section EdsgerGen.



Context {memModelOps : MemoryModelOps mem}.
Instance GlobalLayerSpec : LayerSpecClass := {
  memModelOps := memModelOps;                                            
  GetHighData := global_abstract_data_type 
}.


Context`{global_abdata : !GlobalAbData init_global_abstract_data global_low_level_invariant}.
Definition SWAPCONTRACT_kernel_mode (abd : global_abstract_data_type) := True.
Global Arguments SWAPCONTRACT_kernel_mode / abd.

Class Layer_SWAPCONTRACT_Context_prf  := {
  (* ensuring global empty data matches those in the object definitions *)
  SWAPCONTRACT_init__assetAmount_eq : _assetAmount init_global_abstract_data = (Int256.repr 0);
  SWAPCONTRACT_init__timelocks_eq : _timelocks init_global_abstract_data = (ZMap.init (@ht_default tint_U _));
  SWAPCONTRACT_init__hashlocks_eq : _hashlocks init_global_abstract_data = (ZMap.init (@ht_default tint_hashvalue _));
  SWAPCONTRACT_init__party_eq : _party init_global_abstract_data = (Int256.repr 0);
  SWAPCONTRACT_init__counterparty_eq : _counterparty init_global_abstract_data = (Int256.repr 0);
  SWAPCONTRACT_init__start_eq : _start init_global_abstract_data = (Int256.repr 0);
  SWAPCONTRACT_init__delta_eq : _delta init_global_abstract_data = (Int256.repr 0);
  SWAPCONTRACT_init__unlocked_eq : _unlocked init_global_abstract_data = (ZMap.init (@ht_default tint_bool _));
  SWAPCONTRACT_init__ended_eq : _ended init_global_abstract_data = false;
  SWAPCONTRACT_init__canrefund_eq : _canrefund init_global_abstract_data = false;
  SWAPCONTRACT_init__events_eq : _events init_global_abstract_data = nil;
  SWAPCONTRACT_init__leaders_eq : _leaders init_global_abstract_data = (ZMap.init (@ht_default tint_U _));
  SWAPCONTRACT_init__parties_eq : _parties init_global_abstract_data = (ZMap.init (@ht_default tint_U _));
  SWAPCONTRACT_init__edges_eq : _edges init_global_abstract_data = (Int256Tree.empty (ZMap.t int256));
  SWAPCONTRACT_init__edges_reverse_eq : _edges_reverse init_global_abstract_data = (Int256Tree.empty (ZMap.t int256));
  SWAPCONTRACT_init__party_addr_to_ind_eq : _party_addr_to_ind init_global_abstract_data = (Int256Tree.empty Z32);
  SWAPCONTRACT_init__leader_addr_to_ind_eq : _leader_addr_to_ind init_global_abstract_data = (Int256Tree.empty Z32);
  SWAPCONTRACT_init__party_eq : _party init_global_abstract_data = (Int256.repr 0);
  SWAPCONTRACT_init__counterparty_eq : _counterparty init_global_abstract_data = (Int256.repr 0);
  SWAPCONTRACT_init__hashkeyinit_eq : _hashkeyinit init_global_abstract_data = (ZMap.init {| path := (@ht_default tarray_int_AR3_Z _);
         nextInd := (@ht_default tint_Z32 _)
      |});
  SWAPCONTRACT_init__innerpathinit_eq : _innerpathinit init_global_abstract_data = (ZMap.init {| toleader := (@ht_default tarray_Path_AR1_Path _)
      |});
  SWAPCONTRACT_init__allpaths_eq : _allpaths init_global_abstract_data = (ZMap.init (ZMap.init (@ht_default tHashkeys_Hashkeys _)));
  SWAPCONTRACT_init__res_is_leader_eq : _res_is_leader init_global_abstract_data = false;
  SWAPCONTRACT_init__res_is_party_eq : _res_is_party init_global_abstract_data = false;
  SWAPCONTRACT_init__res_is_edge_eq : _res_is_edge init_global_abstract_data = false;
  SWAPCONTRACT_init__res_has_signed_eq : _res_has_signed init_global_abstract_data = false;
  SWAPCONTRACT_init__res_can_sign_eq : _res_can_sign init_global_abstract_data = false;
  SWAPCONTRACT_init__res_path_len_eq : _res_path_len init_global_abstract_data = (Int256.repr 0)
}.
Context`{CTXT_prf : !Layer_SWAPCONTRACT_Context_prf}.

Instance SWAPCONTRACT_data_ops : CompatDataOps global_abstract_data_type := {
  empty_data := init_global_abstract_data;
  high_level_invariant d := True;
  (* low_level_invariant := global_low_level_invariant; *) (* Omitted in Ethereum backend. 
  kernel_mode d := SWAPCONTRACT_kernel_mode d *)
}.

Instance SWAPCONTRACT_data : CompatData global_abstract_data_type := {
  (* low_level_invariant_incr := AbData_low_level_invariant_incr;
  empty_data_low_level_invariant := AbData_empty_data_low_level_invariant; *) (* Omitted in Ethereum backend. *)
  empty_data_high_level_invariant := I
}.

Instance SWAPCONTRACT_overlay_spec : OverlaySpecClass := {
  (*cdataOpsHigh := SWAPCONTRACT_data_ops;
  cdataHigh := SWAPCONTRACT_data *)
}.



(* (* TODO: add this back in for the Ethereum backend. *)
Global Instance Layer_SWAPCONTRACT'EVMOPCODE_Context_prf : Layer_EVMOPCODE_Context_prf.
Proof. esplit; apply CTXT_prf.
  (*
  - intros; simpl.
    rewrite SWAPCONTRACT_AbData_get_set.
    destruct abd; reflexivity.
  - intros; simpl.
    rewrite SWAPCONTRACT_AbData_get_set, SWAPCONTRACT_AbData_set_set.
    reflexivity.
  - simpl.
    rewrite SWAPCONTRACT_AbData_get_empty_data.
    reflexivity.
  - admit.
  *)
Qed.
Context`{EVMOPCODE_pres_inv : !EVMOPCODE_preserves_invariants}.
*)

Instance SWAPCONTRACT_underlay_spec : UnderlaySpecClass := {
  cdataOpsLow := EVMOPCODE_data_ops;
  cdataLow := EVMOPCODE_data;
  (*GetLowLayer := EVMOPCODE_Layer *)
}.


Section OBJECT_SwapContract_DEFINITION.
  Context`{HM : !HyperMem}.

  (* Object variables *)
  Definition SwapContract__assetAmount_var := {|
    ltype_tp_marker := tint_U;

    ltype_ident := Values.Iident var_SwapContract__assetAmount_ident;
    ltype_ghost := false;

    ltype_get := _assetAmount;
    ltype_set := update__assetAmount;

    ltype_set_ocond := otrue1;
    ltype_get_extra_ocond := otrue1
  |}.
(*TODO: variables.*) (*  Definition SwapContract__assetAmount_globvar : AST.globvar type :=
    let ty := unpair_ty tint_U in
    {| AST.gvar_info := ty;
       AST.gvar_init := AST.Init_space (sizeof ty) :: nil; (* XXX: until we can translate [Cval] to [AST.init_data] *)
       AST.gvar_readonly := false;
       AST.gvar_volatile := false
    |}.*)
  Definition SwapContract__timelocks_var := {|
    ltype_tp_marker := tarray_int_AR1_Z;

    ltype_ident := Values.Iident var_SwapContract__timelocks_ident;
    ltype_ghost := false;

    ltype_get := _timelocks;
    ltype_set := update__timelocks;

    ltype_set_ocond := otrue1;
    ltype_get_extra_ocond := otrue1
  |}.
(*TODO: variables.*) (*  Definition SwapContract__timelocks_globvar : AST.globvar type :=
    let ty := unpair_ty tarray_int_AR1_Z in
    {| AST.gvar_info := ty;
       AST.gvar_init := AST.Init_space (sizeof ty) :: nil; (* XXX: until we can translate [Cval] to [AST.init_data] *)
       AST.gvar_readonly := false;
       AST.gvar_volatile := false
    |}.*)
  Definition SwapContract__hashlocks_var := {|
    ltype_tp_marker := tarray_int_AR1_hashvalue;

    ltype_ident := Values.Iident var_SwapContract__hashlocks_ident;
    ltype_ghost := false;

    ltype_get := _hashlocks;
    ltype_set := update__hashlocks;

    ltype_set_ocond := otrue1;
    ltype_get_extra_ocond := otrue1
  |}.
(*TODO: variables.*) (*  Definition SwapContract__hashlocks_globvar : AST.globvar type :=
    let ty := unpair_ty tarray_int_AR1_hashvalue in
    {| AST.gvar_info := ty;
       AST.gvar_init := AST.Init_space (sizeof ty) :: nil; (* XXX: until we can translate [Cval] to [AST.init_data] *)
       AST.gvar_readonly := false;
       AST.gvar_volatile := false
    |}.*)
  Definition SwapContract__party_var := {|
    ltype_tp_marker := tint_U;

    ltype_ident := Values.Iident var_SwapContract__party_ident;
    ltype_ghost := false;

    ltype_get := _party;
    ltype_set := update__party;

    ltype_set_ocond := otrue1;
    ltype_get_extra_ocond := otrue1
  |}.
(*TODO: variables.*) (*  Definition SwapContract__party_globvar : AST.globvar type :=
    let ty := unpair_ty tint_U in
    {| AST.gvar_info := ty;
       AST.gvar_init := AST.Init_space (sizeof ty) :: nil; (* XXX: until we can translate [Cval] to [AST.init_data] *)
       AST.gvar_readonly := false;
       AST.gvar_volatile := false
    |}.*)
  Definition SwapContract__counterparty_var := {|
    ltype_tp_marker := tint_U;

    ltype_ident := Values.Iident var_SwapContract__counterparty_ident;
    ltype_ghost := false;

    ltype_get := _counterparty;
    ltype_set := update__counterparty;

    ltype_set_ocond := otrue1;
    ltype_get_extra_ocond := otrue1
  |}.
(*TODO: variables.*) (*  Definition SwapContract__counterparty_globvar : AST.globvar type :=
    let ty := unpair_ty tint_U in
    {| AST.gvar_info := ty;
       AST.gvar_init := AST.Init_space (sizeof ty) :: nil; (* XXX: until we can translate [Cval] to [AST.init_data] *)
       AST.gvar_readonly := false;
       AST.gvar_volatile := false
    |}.*)
  Definition SwapContract__start_var := {|
    ltype_tp_marker := tint_U;

    ltype_ident := Values.Iident var_SwapContract__start_ident;
    ltype_ghost := false;

    ltype_get := _start;
    ltype_set := update__start;

    ltype_set_ocond := otrue1;
    ltype_get_extra_ocond := otrue1
  |}.
(*TODO: variables.*) (*  Definition SwapContract__start_globvar : AST.globvar type :=
    let ty := unpair_ty tint_U in
    {| AST.gvar_info := ty;
       AST.gvar_init := AST.Init_space (sizeof ty) :: nil; (* XXX: until we can translate [Cval] to [AST.init_data] *)
       AST.gvar_readonly := false;
       AST.gvar_volatile := false
    |}.*)
  Definition SwapContract__delta_var := {|
    ltype_tp_marker := tint_U;

    ltype_ident := Values.Iident var_SwapContract__delta_ident;
    ltype_ghost := false;

    ltype_get := _delta;
    ltype_set := update__delta;

    ltype_set_ocond := otrue1;
    ltype_get_extra_ocond := otrue1
  |}.
(*TODO: variables.*) (*  Definition SwapContract__delta_globvar : AST.globvar type :=
    let ty := unpair_ty tint_U in
    {| AST.gvar_info := ty;
       AST.gvar_init := AST.Init_space (sizeof ty) :: nil; (* XXX: until we can translate [Cval] to [AST.init_data] *)
       AST.gvar_readonly := false;
       AST.gvar_volatile := false
    |}.*)
  Definition SwapContract__unlocked_var := {|
    ltype_tp_marker := tarray_int_AR1_bool;

    ltype_ident := Values.Iident var_SwapContract__unlocked_ident;
    ltype_ghost := false;

    ltype_get := _unlocked;
    ltype_set := update__unlocked;

    ltype_set_ocond := otrue1;
    ltype_get_extra_ocond := otrue1
  |}.
(*TODO: variables.*) (*  Definition SwapContract__unlocked_globvar : AST.globvar type :=
    let ty := unpair_ty tarray_int_AR1_bool in
    {| AST.gvar_info := ty;
       AST.gvar_init := AST.Init_space (sizeof ty) :: nil; (* XXX: until we can translate [Cval] to [AST.init_data] *)
       AST.gvar_readonly := false;
       AST.gvar_volatile := false
    |}.*)
  Definition SwapContract__ended_var := {|
    ltype_tp_marker := tint_bool;

    ltype_ident := Values.Iident var_SwapContract__ended_ident;
    ltype_ghost := false;

    ltype_get := _ended;
    ltype_set := update__ended;

    ltype_set_ocond := otrue1;
    ltype_get_extra_ocond := otrue1
  |}.
(*TODO: variables.*) (*  Definition SwapContract__ended_globvar : AST.globvar type :=
    let ty := unpair_ty tint_bool in
    {| AST.gvar_info := ty;
       AST.gvar_init := AST.Init_space (sizeof ty) :: nil; (* XXX: until we can translate [Cval] to [AST.init_data] *)
       AST.gvar_readonly := false;
       AST.gvar_volatile := false
    |}.*)
  Definition SwapContract__canrefund_var := {|
    ltype_tp_marker := tint_bool;

    ltype_ident := Values.Iident var_SwapContract__canrefund_ident;
    ltype_ghost := false;

    ltype_get := _canrefund;
    ltype_set := update__canrefund;

    ltype_set_ocond := otrue1;
    ltype_get_extra_ocond := otrue1
  |}.
(*TODO: variables.*) (*  Definition SwapContract__canrefund_globvar : AST.globvar type :=
    let ty := unpair_ty tint_bool in
    {| AST.gvar_info := ty;
       AST.gvar_init := AST.Init_space (sizeof ty) :: nil; (* XXX: until we can translate [Cval] to [AST.init_data] *)
       AST.gvar_readonly := false;
       AST.gvar_volatile := false
    |}.*)

  Definition SwapContract_initialize := {|
    FC_ident_start := BuiltinBase_local_ident_start;
    FC_params := (cons (* amount : *) int_U_pair (cons (* counterparty : *) int_U_pair (cons (* start : *) int_U_pair (cons (* delta : *) int_U_pair nil))));
    FC_returns := void_unit_pair;
    FC_body := (CCsequence
      (CCassert (CCyield (ECbinop tint_bool Oge
        (ECtempvar tint_U 13%positive (* start *))
        (ECbinop tint_U Oadd
          (@ECbuiltin0 _ _  _ builtin0_timestamp_impl)
          (ECtempvar tint_U 14%positive (* delta *))))))
      (CCsequence
        (CCstore
          (LCvar SwapContract__counterparty_var)
          (ECtempvar tint_U 12%positive (* counterparty *)))
        (CCsequence
          (CCstore
            (LCvar SwapContract__assetAmount_var)
            (ECtempvar tint_U 11%positive (* amount *)))
          (CCsequence
            (CCstore
              (LCvar SwapContract__party_var)
              (@ECbuiltin0 _ _  _ builtin0_caller_impl))
            (CCsequence
              (CCstore
                (LCvar SwapContract__start_var)
                (ECtempvar tint_U 13%positive (* start *)))
              (CCsequence
                (CCstore
                  (LCvar SwapContract__delta_var)
                  (ECtempvar tint_U 14%positive (* delta *)))
                (CCsequence
                  (CCstore
                    (LCvar SwapContract__canrefund_var)
                    (ECconst_int256 tint_bool false Int256.zero))
                  (CCsequence
                    (CCfor (* i := *) 16%positive 17%positive (ECconst_int256 tint_Z32 0 (Int256.repr 0)) (ECconst_int256 tint_Z32 1 (Int256.repr 1))
                      (CCstore
                        (LCindex tint_bool
                          (LCvar SwapContract__unlocked_var)
                          (ECtempvar tint_Z32 16%positive (* i *)))
                        (ECconst_int256 tint_bool false Int256.zero)))
                    (CCyield (ECconst_int256 tvoid_unit tt Int256.zero))))))))))
  |}.
  Lemma SwapContract_initialize_wf
      : synth_func_wellformed SwapContract_initialize.
  Proof. solve_wellformed. Defined.
  Definition SwapContract_initialize_opt :int256 -> int256 -> int256 -> int256 ->  machine_env -> DS unit  := 
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify
             GetHighData is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events]
  in synth_func_spec_opt SwapContract_initialize SwapContract_initialize_wf.
  Definition SwapContract_initialize_spec_hlist_opt args :=
    @apply_param_func SwapContract_initialize.(FC_params) _
                      (SwapContract_initialize_opt) args.
  Definition SwapContract_initialize_spec_cond :=
   (*Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify runStateT evalStateT execStateT
             is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set hlist_hd
             omap2 oand2 oimply2 oabsorption2 hlist_param_func (* SpecTree.get SpecTree.get_eq SpecTree.set *)
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events]
  in *)
  synth_func_spec_cond SwapContract_initialize SwapContract_initialize_wf.

  Definition SwapContract_initialize_prim := {|
    PRIMident := ident_SwapContract_initialize;
    (* PRIMcc := AST.cc_default; *)
    PRIMghost := false;
    PRIMpure := false;
    PRIMargt_marker := SwapContract_initialize.(FC_params);
    PRIMret_marker := SwapContract_initialize.(FC_returns);
    PRIMcond := SwapContract_initialize_spec_cond;
    (* PRIMsem := SwapContract_initialize_spec_hlist; *)
    PRIMsem_opt := SwapContract_initialize_spec_hlist_opt
  |}.

  Lemma SwapContract_initialize_spec_hlist_opt_eq :
    SwapContract_initialize_spec_hlist_opt =
    fun args => apply_param_func
      (synth_func_spec_opt SwapContract_initialize SwapContract_initialize_wf)
      args.
  Proof.
    (*cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify
             GetHighData is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events]. *)
     reflexivity. 
  Qed.
  Definition SwapContract_initialize_cfun :=
  Eval cbv in synth_func_func SwapContract_initialize.

  Definition SwapContract_initialize_cond  a0 a1 a2 a3 me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify runStateT evalStateT execStateT
             is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set hlist_hd
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events]
    in
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    ht_ft_cond a2 -> ht_valid_ft_cond a2 ->
    ht_ft_cond a3 -> ht_valid_ft_cond a3 ->
    high_level_invariant d ->
    synth_func_cond SwapContract_initialize SwapContract_initialize_wf
								      a0 a1 a2 a3 me d.
  
  Lemma SwapContract_initialize_cond_eq : forall  a0 a1 a2 a3 me d, 
    SwapContract_initialize_cond  a0 a1 a2 a3 me d ->
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    ht_ft_cond a2 -> ht_valid_ft_cond a2 ->
    ht_ft_cond a3 -> ht_valid_ft_cond a3 ->
    high_level_invariant d ->
    synth_func_cond SwapContract_initialize SwapContract_initialize_wf  a0 a1 a2 a3 me d.
    Proof.
      intros  a0 a1 a2 a3 me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify runStateT evalStateT execStateT
             is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set hlist_hd
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events].
       exact H_cond.
    Qed.

  Definition SwapContract_initialize_obligation  a0 a1 a2 a3 me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify runStateT evalStateT execStateT
             is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set hlist_hd
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events]
    in
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    ht_ft_cond a2 -> ht_valid_ft_cond a2 ->
    ht_ft_cond a3 -> ht_valid_ft_cond a3 ->
    high_level_invariant d ->
    synth_func_obligation SwapContract_initialize SwapContract_initialize_wf
								      a0 a1 a2 a3 me d.
  
  Lemma SwapContract_initialize_obligation_eq : forall  a0 a1 a2 a3 me d, 
    SwapContract_initialize_obligation  a0 a1 a2 a3 me d ->
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    ht_ft_cond a2 -> ht_valid_ft_cond a2 ->
    ht_ft_cond a3 -> ht_valid_ft_cond a3 ->
    high_level_invariant d ->
    synth_func_obligation SwapContract_initialize SwapContract_initialize_wf  a0 a1 a2 a3 me d.
    Proof.
      intros  a0 a1 a2 a3 me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify runStateT evalStateT execStateT
             is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set hlist_hd
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events].
       exact H_cond.
    Qed.

  Definition SwapContract_initialize_spec :=
  Eval cbv [sf_mem sf_return fst snd SwapContract_initialize_opt] in
    fun  a0 a1 a2 a3 me => execStateT (SwapContract_initialize_opt a0 a1 a2 a3 me).
  Lemma SwapContract_initialize_spec_eq :
    SwapContract_initialize_spec =
    fun  a0 a1 a2 a3 me => execStateT (synth_func_spec_opt SwapContract_initialize SwapContract_initialize_wf a0 a1 a2 a3 me).
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
          ret bind mzero get put gets guard modify
          GetHighData is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set
          (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
          _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events].
    reflexivity.
  Qed.

Global Opaque SwapContract_initialize_opt.

  Definition SwapContract_unlock := {|
    FC_ident_start := BuiltinBase_local_ident_start;
    FC_params := (cons (* leader_addr : *) int_U_pair (cons (* secret : *) int_U_pair nil));
    FC_returns := void_unit_pair;
    FC_body := (CClet (* is_leader := *) 13%positive
      (CCcall DiGraph_is_leader_prim
        (HCons int_U_pair _
          (ECtempvar tint_U 11%positive (* leader_addr *))
          HNil))
      (CClet (* party := *) 14%positive
        (CCload (LCvar SwapContract__party_var))
        (CClet (* counterparty := *) 15%positive
          (CCload (LCvar SwapContract__counterparty_var))
          (CClet (* ld_ind := *) 16%positive
            (CCcall DiGraph_get_leader_ind_prim
              (HCons int_U_pair _
                (ECtempvar tint_U 11%positive (* leader_addr *))
                HNil))
            (CClet (* hashlock := *) 17%positive
              (CCload (LCindex tint_hashvalue
                (LCvar SwapContract__hashlocks_var)
                (ECtempvar tint_Z32 16%positive (* ld_ind *))))
              (CCsequence
                (CCassert (CCyield (ECtempvar tint_bool 13%positive (* is_leader *))))
                (CCsequence
                  (CCassert (CCyield (ECbinop tint_bool Oeq
                    (@ECbuiltin0 _ _  _ builtin0_caller_impl)
                    (ECtempvar tint_U 15%positive (* counterparty *)))))
                  (CCsequence
                    (CCassert (CCyield (ECbinop tint_bool Oeq
                      (ECtempvar tint_hashvalue 17%positive (* hashlock *))
                      (ECunop tint_hashvalue Osha_1 (ECtempvar tint_U 12%positive (* secret *))))))
                    (CClet (* path_verified := *) 21%positive
                      (CCcall DiGraph_valid_path_prim
                        (HCons int_U_pair _
                          (ECtempvar tint_U 14%positive (* party *))
                          (HCons int_U_pair _
                            (ECtempvar tint_U 15%positive (* counterparty *))
                            (HCons int_U_pair _
                              (ECtempvar tint_U 11%positive (* leader_addr *))
                              HNil))))
                      (CClet (* path_len := *) 22%positive
                        (CCcall DiGraph_get_path_len_prim
                          (HCons int_U_pair _
                            (ECtempvar tint_U 14%positive (* party *))
                            (HCons int_U_pair _
                              (ECtempvar tint_U 15%positive (* counterparty *))
                              (HCons int_U_pair _
                                (ECtempvar tint_U 11%positive (* leader_addr *))
                                HNil))))
                        (CClet (* start := *) 23%positive
                          (CCload (LCvar SwapContract__start_var))
                          (CClet (* delta := *) 24%positive
                            (CCload (LCvar SwapContract__delta_var))
                            (CCsequence
                              (CCassert (CCyield (ECbinop tint_bool Olt
                                (@ECbuiltin0 _ _  _ builtin0_timestamp_impl)
                                (ECbinop tint_U Oadd
                                  (ECtempvar tint_U 23%positive (* start *))
                                  (ECbinop tint_U Omul
                                    (ECbinop tint_U Oadd
                                      (ECconst_int256 tint_U (Int256.repr 3) (Int256.repr 3))
                                      (ECtempvar tint_U 22%positive (* path_len *)))
                                    (ECtempvar tint_U 24%positive (* delta *)))))))
                              (CCsequence
                                (CCassert (CCyield (ECtempvar tint_bool 21%positive (* path_verified *))))
                                (CCsequence
                                  (CCstore
                                    (LCindex tint_bool
                                      (LCvar SwapContract__unlocked_var)
                                      (ECtempvar tint_Z32 16%positive (* ld_ind *)))
                                    (ECconst_int256 tint_bool true Int256.one))
                                  (CCyield (ECconst_int256 tvoid_unit tt Int256.zero)))))))))))))))))
  |}.
  Lemma SwapContract_unlock_wf
      : synth_func_wellformed SwapContract_unlock.
  Proof. solve_wellformed. Defined.
  Definition SwapContract_unlock_opt :int256 -> int256 ->  machine_env -> DS unit  := 
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify
             GetHighData is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events]
  in synth_func_spec_opt SwapContract_unlock SwapContract_unlock_wf.
  Definition SwapContract_unlock_spec_hlist_opt args :=
    @apply_param_func SwapContract_unlock.(FC_params) _
                      (SwapContract_unlock_opt) args.
  Definition SwapContract_unlock_spec_cond :=
   (*Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify runStateT evalStateT execStateT
             is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set hlist_hd
             omap2 oand2 oimply2 oabsorption2 hlist_param_func (* SpecTree.get SpecTree.get_eq SpecTree.set *)
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events]
  in *)
  synth_func_spec_cond SwapContract_unlock SwapContract_unlock_wf.

  Definition SwapContract_unlock_prim := {|
    PRIMident := ident_SwapContract_unlock;
    (* PRIMcc := AST.cc_default; *)
    PRIMghost := false;
    PRIMpure := false;
    PRIMargt_marker := SwapContract_unlock.(FC_params);
    PRIMret_marker := SwapContract_unlock.(FC_returns);
    PRIMcond := SwapContract_unlock_spec_cond;
    (* PRIMsem := SwapContract_unlock_spec_hlist; *)
    PRIMsem_opt := SwapContract_unlock_spec_hlist_opt
  |}.

  Lemma SwapContract_unlock_spec_hlist_opt_eq :
    SwapContract_unlock_spec_hlist_opt =
    fun args => apply_param_func
      (synth_func_spec_opt SwapContract_unlock SwapContract_unlock_wf)
      args.
  Proof.
    (*cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify
             GetHighData is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events]. *)
     reflexivity. 
  Qed.
  Definition SwapContract_unlock_cfun :=
  Eval cbv in synth_func_func SwapContract_unlock.

  Definition SwapContract_unlock_cond  a0 a1 me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify runStateT evalStateT execStateT
             is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set hlist_hd
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events]
    in
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    high_level_invariant d ->
    synth_func_cond SwapContract_unlock SwapContract_unlock_wf
								      a0 a1 me d.
  
  Lemma SwapContract_unlock_cond_eq : forall  a0 a1 me d, 
    SwapContract_unlock_cond  a0 a1 me d ->
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    high_level_invariant d ->
    synth_func_cond SwapContract_unlock SwapContract_unlock_wf  a0 a1 me d.
    Proof.
      intros  a0 a1 me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify runStateT evalStateT execStateT
             is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set hlist_hd
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events].
       exact H_cond.
    Qed.

  Definition SwapContract_unlock_obligation  a0 a1 me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify runStateT evalStateT execStateT
             is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set hlist_hd
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events]
    in
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    high_level_invariant d ->
    synth_func_obligation SwapContract_unlock SwapContract_unlock_wf
								      a0 a1 me d.
  
  Lemma SwapContract_unlock_obligation_eq : forall  a0 a1 me d, 
    SwapContract_unlock_obligation  a0 a1 me d ->
    ht_ft_cond a0 -> ht_valid_ft_cond a0 ->
    ht_ft_cond a1 -> ht_valid_ft_cond a1 ->
    high_level_invariant d ->
    synth_func_obligation SwapContract_unlock SwapContract_unlock_wf  a0 a1 me d.
    Proof.
      intros  a0 a1 me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify runStateT evalStateT execStateT
             is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set hlist_hd
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events].
       exact H_cond.
    Qed.

  Definition SwapContract_unlock_spec :=
  Eval cbv [sf_mem sf_return fst snd SwapContract_unlock_opt] in
    fun  a0 a1 me => execStateT (SwapContract_unlock_opt a0 a1 me).
  Lemma SwapContract_unlock_spec_eq :
    SwapContract_unlock_spec =
    fun  a0 a1 me => execStateT (synth_func_spec_opt SwapContract_unlock SwapContract_unlock_wf a0 a1 me).
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
          ret bind mzero get put gets guard modify
          GetHighData is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set
          (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
          _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events].
    reflexivity.
  Qed.

Global Opaque SwapContract_unlock_opt.

  Definition SwapContract_claim := {|
    FC_ident_start := BuiltinBase_local_ident_start;
    FC_params := nil;
    FC_returns := void_unit_pair;
    FC_body := (CClet (* counterparty := *) 12%positive
      (CCload (LCvar SwapContract__counterparty_var))
      (CClet (* assetAmount := *) 13%positive
        (CCload (LCvar SwapContract__assetAmount_var))
        (CClet (* ended := *) 14%positive
          (CCload (LCvar SwapContract__ended_var))
          (CCsequence
            (CCassert (CCyield (ECunop tint_bool Onotbool (ECtempvar tint_bool 14%positive (* ended *)))))
            (CCsequence
              (CCassert (CCyield (ECbinop tint_bool Oeq
                (ECtempvar tint_U 12%positive (* counterparty *))
                (@ECbuiltin0 _ _  _ builtin0_caller_impl))))
              (CCsequence
                (CCfor (* i := *) 17%positive 18%positive (ECconst_int256 tint_Z32 0 (Int256.repr 0)) (ECconst_int256 tint_Z32 1 (Int256.repr 1))
                  (CClet (* unlock_status := *) 19%positive
                    (CCload (LCindex tint_bool
                      (LCvar SwapContract__unlocked_var)
                      (ECtempvar tint_Z32 17%positive (* i *))))
                    (CCassert (CCyield (ECbinop tint_bool Oeq
                      (ECtempvar tint_bool 19%positive (* unlock_status *))
                      (ECconst_int256 tint_bool true Int256.one))))))
                (CCsequence
                  (CCcall EVMOpcode_transfer_prim
                    (HCons int_U_pair _
                      (ECtempvar tint_U 12%positive (* counterparty *))
                      (HCons int_U_pair _
                        (ECtempvar tint_U 13%positive (* assetAmount *))
                        HNil)))
                  (CCsequence
                    (CCstore
                      (LCvar SwapContract__ended_var)
                      (ECconst_int256 tint_bool true Int256.one))
                    (CCyield (ECconst_int256 tvoid_unit tt Int256.zero))))))))))
  |}.
  Lemma SwapContract_claim_wf
      : synth_func_wellformed SwapContract_claim.
  Proof. solve_wellformed. Defined.
  Definition SwapContract_claim_opt : machine_env -> DS unit  := 
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify
             GetHighData is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events]
  in synth_func_spec_opt SwapContract_claim SwapContract_claim_wf.
  Definition SwapContract_claim_spec_hlist_opt args :=
    @apply_param_func SwapContract_claim.(FC_params) _
                      (SwapContract_claim_opt) args.
  Definition SwapContract_claim_spec_cond :=
   (*Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify runStateT evalStateT execStateT
             is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set hlist_hd
             omap2 oand2 oimply2 oabsorption2 hlist_param_func (* SpecTree.get SpecTree.get_eq SpecTree.set *)
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events]
  in *)
  synth_func_spec_cond SwapContract_claim SwapContract_claim_wf.

  Definition SwapContract_claim_prim := {|
    PRIMident := ident_SwapContract_claim;
    (* PRIMcc := AST.cc_default; *)
    PRIMghost := false;
    PRIMpure := false;
    PRIMargt_marker := SwapContract_claim.(FC_params);
    PRIMret_marker := SwapContract_claim.(FC_returns);
    PRIMcond := SwapContract_claim_spec_cond;
    (* PRIMsem := SwapContract_claim_spec_hlist; *)
    PRIMsem_opt := SwapContract_claim_spec_hlist_opt
  |}.

  Lemma SwapContract_claim_spec_hlist_opt_eq :
    SwapContract_claim_spec_hlist_opt =
    fun args => apply_param_func
      (synth_func_spec_opt SwapContract_claim SwapContract_claim_wf)
      args.
  Proof.
    (*cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify
             GetHighData is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events]. *)
     reflexivity. 
  Qed.
  Definition SwapContract_claim_cfun :=
  Eval cbv in synth_func_func SwapContract_claim.

  Definition SwapContract_claim_cond  me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify runStateT evalStateT execStateT
             is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set hlist_hd
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events]
    in
    high_level_invariant d ->
    synth_func_cond SwapContract_claim SwapContract_claim_wf
								      me d.
  
  Lemma SwapContract_claim_cond_eq : forall  me d, 
    SwapContract_claim_cond  me d ->
    high_level_invariant d ->
    synth_func_cond SwapContract_claim SwapContract_claim_wf  me d.
    Proof.
      intros  me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify runStateT evalStateT execStateT
             is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set hlist_hd
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events].
       exact H_cond.
    Qed.

  Definition SwapContract_claim_obligation  me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify runStateT evalStateT execStateT
             is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set hlist_hd
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events]
    in
    high_level_invariant d ->
    synth_func_obligation SwapContract_claim SwapContract_claim_wf
								      me d.
  
  Lemma SwapContract_claim_obligation_eq : forall  me d, 
    SwapContract_claim_obligation  me d ->
    high_level_invariant d ->
    synth_func_obligation SwapContract_claim SwapContract_claim_wf  me d.
    Proof.
      intros  me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify runStateT evalStateT execStateT
             is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set hlist_hd
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events].
       exact H_cond.
    Qed.

  Definition SwapContract_claim_spec :=
  Eval cbv [sf_mem sf_return fst snd SwapContract_claim_opt] in
    fun  me => execStateT (SwapContract_claim_opt me).
  Lemma SwapContract_claim_spec_eq :
    SwapContract_claim_spec =
    fun  me => execStateT (synth_func_spec_opt SwapContract_claim SwapContract_claim_wf me).
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
          ret bind mzero get put gets guard modify
          GetHighData is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set
          (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
          _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events].
    reflexivity.
  Qed.

Global Opaque SwapContract_claim_opt.

  Definition SwapContract_refund := {|
    FC_ident_start := BuiltinBase_local_ident_start;
    FC_params := nil;
    FC_returns := void_unit_pair;
    FC_body := (CClet (* party := *) 12%positive
      (CCload (LCvar SwapContract__party_var))
      (CClet (* assetAmount := *) 13%positive
        (CCload (LCvar SwapContract__assetAmount_var))
        (CClet (* ended := *) 14%positive
          (CCload (LCvar SwapContract__ended_var))
          (CClet (* start := *) 15%positive
            (CCload (LCvar SwapContract__start_var))
            (CCsequence
              (CCstore
                (LCvar SwapContract__canrefund_var)
                (ECconst_int256 tint_bool false Int256.zero))
              (CCsequence
                (CCassert (CCyield (ECunop tint_bool Onotbool (ECtempvar tint_bool 14%positive (* ended *)))))
                (CCsequence
                  (CCassert (CCyield (ECbinop tint_bool Oeq
                    (ECtempvar tint_U 12%positive (* party *))
                    (@ECbuiltin0 _ _  _ builtin0_caller_impl))))
                  (CCsequence
                    (CCfor (* i := *) 18%positive 19%positive (ECconst_int256 tint_Z32 0 (Int256.repr 0)) (ECconst_int256 tint_Z32 1 (Int256.repr 1))
                      (CClet (* isunlocked := *) 20%positive
                        (CCload (LCindex tint_bool
                          (LCvar SwapContract__unlocked_var)
                          (ECtempvar tint_Z32 18%positive (* i *))))
                        (CClet (* timeout := *) 21%positive
                          (CCload (LCindex tint_U
                            (LCvar SwapContract__timelocks_var)
                            (ECtempvar tint_Z32 18%positive (* i *))))
                          (CCifthenelse (ECbinop tint_bool Oand
                              (ECbinop tint_bool Oeq
                                (ECtempvar tint_bool 20%positive (* isunlocked *))
                                (ECconst_int256 tint_bool false Int256.zero))
                              (ECbinop tint_bool Oge
                                (@ECbuiltin0 _ _  _ builtin0_timestamp_impl)
                                (ECbinop tint_U Oadd
                                  (ECtempvar tint_U 15%positive (* start *))
                                  (ECtempvar tint_U 21%positive (* timeout *)))))
                            (CCstore
                              (LCvar SwapContract__canrefund_var)
                              (ECconst_int256 tint_bool true Int256.one))
                            (CCyield (ECconst_int256 tvoid_unit tt Int256.zero))))))
                    (CClet (* canrefund := *) 22%positive
                      (CCload (LCvar SwapContract__canrefund_var))
                      (CCsequence
                        (CCassert (CCyield (ECtempvar tint_bool 22%positive (* canrefund *))))
                        (CCsequence
                          (CCcall EVMOpcode_transfer_prim
                            (HCons int_U_pair _
                              (ECtempvar tint_U 12%positive (* party *))
                              (HCons int_U_pair _
                                (ECtempvar tint_U 13%positive (* assetAmount *))
                                HNil)))
                          (CCsequence
                            (CCstore
                              (LCvar SwapContract__ended_var)
                              (ECconst_int256 tint_bool true Int256.one))
                            (CCyield (ECconst_int256 tvoid_unit tt Int256.zero))))))))))))))
  |}.
  Lemma SwapContract_refund_wf
      : synth_func_wellformed SwapContract_refund.
  Proof. solve_wellformed. Defined.
  Definition SwapContract_refund_opt : machine_env -> DS unit  := 
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify
             GetHighData is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events]
  in synth_func_spec_opt SwapContract_refund SwapContract_refund_wf.
  Definition SwapContract_refund_spec_hlist_opt args :=
    @apply_param_func SwapContract_refund.(FC_params) _
                      (SwapContract_refund_opt) args.
  Definition SwapContract_refund_spec_cond :=
   (*Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify runStateT evalStateT execStateT
             is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set hlist_hd
             omap2 oand2 oimply2 oabsorption2 hlist_param_func (* SpecTree.get SpecTree.get_eq SpecTree.set *)
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events]
  in *)
  synth_func_spec_cond SwapContract_refund SwapContract_refund_wf.

  Definition SwapContract_refund_prim := {|
    PRIMident := ident_SwapContract_refund;
    (* PRIMcc := AST.cc_default; *)
    PRIMghost := false;
    PRIMpure := false;
    PRIMargt_marker := SwapContract_refund.(FC_params);
    PRIMret_marker := SwapContract_refund.(FC_returns);
    PRIMcond := SwapContract_refund_spec_cond;
    (* PRIMsem := SwapContract_refund_spec_hlist; *)
    PRIMsem_opt := SwapContract_refund_spec_hlist_opt
  |}.

  Lemma SwapContract_refund_spec_hlist_opt_eq :
    SwapContract_refund_spec_hlist_opt =
    fun args => apply_param_func
      (synth_func_spec_opt SwapContract_refund SwapContract_refund_wf)
      args.
  Proof.
    (*cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify
             GetHighData is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events]. *)
     reflexivity. 
  Qed.
  Definition SwapContract_refund_cfun :=
  Eval cbv in synth_func_func SwapContract_refund.

  Definition SwapContract_refund_cond  me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify runStateT evalStateT execStateT
             is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set hlist_hd
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events]
    in
    high_level_invariant d ->
    synth_func_cond SwapContract_refund SwapContract_refund_wf
								      me d.
  
  Lemma SwapContract_refund_cond_eq : forall  me d, 
    SwapContract_refund_cond  me d ->
    high_level_invariant d ->
    synth_func_cond SwapContract_refund SwapContract_refund_wf  me d.
    Proof.
      intros  me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify runStateT evalStateT execStateT
             is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set hlist_hd
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events].
       exact H_cond.
    Qed.

  Definition SwapContract_refund_obligation  me d  :=
  Eval cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify runStateT evalStateT execStateT
             is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set hlist_hd
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events]
    in
    high_level_invariant d ->
    synth_func_obligation SwapContract_refund SwapContract_refund_wf
								      me d.
  
  Lemma SwapContract_refund_obligation_eq : forall  me d, 
    SwapContract_refund_obligation  me d ->
    high_level_invariant d ->
    synth_func_obligation SwapContract_refund SwapContract_refund_wf  me d.
    Proof.
      intros  me d H_cond.
      cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
             ret bind mzero get put gets guard modify runStateT evalStateT execStateT
             is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set hlist_hd
             (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
             _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events].
       exact H_cond.
    Qed.

  Definition SwapContract_refund_spec :=
  Eval cbv [sf_mem sf_return fst snd SwapContract_refund_opt] in
    fun  me => execStateT (SwapContract_refund_opt me).
  Lemma SwapContract_refund_spec_eq :
    SwapContract_refund_spec =
    fun  me => execStateT (synth_func_spec_opt SwapContract_refund SwapContract_refund_wf me).
  Proof.
    cbv -[Int256.modulus zeq zle zlt Z.iter Z.le Z.lt Z.gt Z.ge Z.eqb Z.leb Z.ltb Z.geb Z.gtb Z.mul Z.div Z.modulo Z.add Z.sub Z.shiftl Z.shiftr Z.lxor Z.land Z.lor Int256.add Int256.sub Int256.mul Int256.modu Int256.divu Int256.cmpu Int256.not Int256.and Int256.or Int256.xor Int256.shl Int256.shru Ziteri Z.of_nat List.length HyperType.Hquery0 hashvalue_eqb
          ret bind mzero get put gets guard modify
          GetHighData is_true bool_dec ZMap.get ZMap.set Int256Tree.get Int256Tree.set
          (fun src e_set => (Int256Map.get src e_set)) (fun pt ld => Int256.one)
          _assetAmount update__assetAmount _timelocks update__timelocks _hashlocks update__hashlocks _party update__party _counterparty update__counterparty _start update__start _delta update__delta _unlocked update__unlocked _ended update__ended _canrefund update__canrefund _leaders update__leaders _parties update__parties _edges update__edges _edges_reverse update__edges_reverse _party_addr_to_ind update__party_addr_to_ind _leader_addr_to_ind update__leader_addr_to_ind _party update__party _counterparty update__counterparty _hashkeyinit update__hashkeyinit _innerpathinit update__innerpathinit _allpaths update__allpaths _res_is_leader update__res_is_leader _res_is_party update__res_is_party _res_is_edge update__res_is_edge _res_has_signed update__res_has_signed _res_can_sign update__res_can_sign _res_path_len update__res_path_len _events update__events].
    reflexivity.
  Qed.

Global Opaque SwapContract_refund_opt.
End OBJECT_SwapContract_DEFINITION.
(* (*Temporarily omitted in the Ethereum version.*)

Section LAYER_SWAPCONTRACT_DEFINITION.
  Definition SWAPCONTRACT_swapcontract_initialize_prim := SwapContract_initialize_prim.
  Definition SWAPCONTRACT_swapcontract_unlock_prim := SwapContract_unlock_prim.
  Definition SWAPCONTRACT_swapcontract_claim_prim := SwapContract_claim_prim.
  Definition SWAPCONTRACT_swapcontract_refund_prim := SwapContract_refund_prim.

  Class SWAPCONTRACT_preserves_invariants := {
    SWAPCONTRACT_SwapContract_initialize_preserves_invariants :>
      CompatGenSem.PreservesInvariants SwapContract_initialize_spec;
    SWAPCONTRACT_SwapContract_unlock_preserves_invariants :>
      CompatGenSem.PreservesInvariants SwapContract_unlock_spec;
    SWAPCONTRACT_SwapContract_claim_preserves_invariants :>
      CompatGenSem.PreservesInvariants SwapContract_claim_spec;
    SWAPCONTRACT_SwapContract_refund_preserves_invariants :>
      CompatGenSem.PreservesInvariants SwapContract_refund_spec
  }.
  Context`{SWAPCONTRACT_pres_inv : !SWAPCONTRACT_preserves_invariants}.

  Definition SWAPCONTRACT_Layer : CompatLayerDef.compatlayer GetHighDataX :=
    initialize  CompatGenSem.gensem SwapContract_initialize_spec
       unlock  CompatGenSem.gensem SwapContract_unlock_spec
       claim  CompatGenSem.gensem SwapContract_claim_spec
       refund  CompatGenSem.gensem SwapContract_refund_spec.
End LAYER_SWAPCONTRACT_DEFINITION.
*)
End EdsgerGen.
